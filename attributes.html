<!-- SPDX-License-Identifier: MPL-2.0 -->

<!DOCTYPE html>
<html lang="en">

<head>
  <meta
    http-equiv="Content-Security-Policy"
    content="trusted-types test-policy; require-trusted-types-for 'script';"
  />

  <link
    rel="stylesheet"
    href="./styles.css"
  >
</head>

<body>
  <div>
    <h1>Trusted Types Tests of Attributes</h1>
    <p>
      As is this page displays the coverage of element-specific attributes.
      For full coverage:
      <button
        disabled
        id="full-coverage"
      >
        click here
      </button>
    </p>
  </div>

  <hr>

  <div>
    <p>
      LEGEND:
      <span class="covered">covered</span>: trusted types do apply.
      <span class="not-covered">not covered</span>: trusted types does not apply.
    </p>
  </div>

  <noscript>
    <p>
      This page tests
      <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API"
      >Trusted Types</a>,
      which requires JavaScript to be enabled.
      Please enable JavaScript to run the Trusted Types tests.
    </p>
  </noscript>

  <div id="no-trusted-types" hidden>
    This browser does not support Trusted Types. Trusted Types tests cannot be
    run. Please switch to a
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API#browser_compatibility"
    >browser with Trusted Types support</a>.
  </div>

  <div id="covered"></div>
  <div id="caught"></div>
  <div id="uncovered"></div>
  <div id="shadow" hidden></div>

  <script src="./helpers.js"></script>
  <script type="module">
  let baseObject = HTMLElement;
  const $btn = document.getElementById("full-coverage");

  if (hasTrustedTypes()) {
    await test();
    $btn.disabled = false;
  } else {
    document.getElementById("no-trusted-types").hidden = false;
  }

  $btn.addEventListener("click", async () => {
    $btn.disabled = true;

    // Change the base object in order to cover all attributes
    baseObject = Object;

    // Reset the results
    $COVERED.innerText = "";
    $CAUGHT.innerText = "";
    $UNCOVERED.innerText = "";

    // Re-run the tests
    await test();
  });

  // ---

  async function test() {
    for (const elementClass of getHTMLElements()) {
      const tagName = elementClassToTagName(elementClass);
      const el = createTestElement(tagName);
      for (const attr of getElementAttributeProperties(el)) {
        const cases = [
          {
            name: () => `${elementClass}.${attr}=.`,
            test: () => el[attr] = UNTRUSTED,
          },
          {
            name: () => `${elementClass}.setAttribute('${attr}', .)`,
            test: () => el.setAttribute(attr, UNTRUSTED),
          },
          {
            name: () => `${elementClass}.setAttributeNS('', '${attr}', .)`,
            test: () => el.setAttributeNS("", attr, UNTRUSTED),
          },
          {
            name: () => `${elementClass}.setAttributeNS('ns', '${attr}', .)`,
            test: () => el.setAttributeNS("ns", attr, UNTRUSTED),
          },
          {
            name: () => `document.createAttribute('${attr}').value=.`,
            test: () => {
              const attribute = document.createAttribute(attr);
              attribute.value = UNTRUSTED;
            },
          },
          {
            name: () => `document.createAttributeNS('', '${attr}').value=.`,
            test: () => {
              const attribute = document.createAttributeNS("", attr);
              attribute.value = UNTRUSTED;
            },
          },
          {
            name: () => `document.createAttributeNS('ns', '${attr}').value=.`,
            test: () => {
              const attribute = document.createAttributeNS("ns", attr);
              attribute.value = UNTRUSTED;
            },
          },
          {
            name: () => `${elementClass}.setAttributeNode([${attr}])`,
            test: () => {
              const attribute = document.createAttribute(attr);
              attribute.value = UNTRUSTED;
              el.setAttributeNode(attribute);
            },
          },
        ];

        for (const tc of cases) {
          await testAndReport(tc.name(), tc.test);
        }
      }
    }
  }

  function elementClassToTagName(element) {
    const tagName = element
      .replace(/^HTML/, "")
      .replace(/Element$/, "")
      .toLowerCase();

    const corrections = {
      anchor: "a",
      dlist: "dl",
      olist: "ol",
      ulist: "ul",
    };
    if (Object.hasOwn(corrections, tagName)) {
      return corrections[tagName];
    }

    return tagName;
  }

  function getHTMLElements() {
    return Reflect.ownKeys(window)
      .filter(key => {
        const value = window[key];
        return typeof value === "function" &&
          value.prototype instanceof HTMLElement &&
          key.startsWith("HTML");
      })
      .toSorted();
  }

  function getElementAttributeProperties(element) {
    const properties = new Set();

    let proto = Object.getPrototypeOf(element);
    while (proto && proto !== baseObject.prototype) {
      for (const key of Object.getOwnPropertyNames(proto)) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, key);
        if (!descriptor) {
          continue;
        }

        if (!descriptor.set && !descriptor.writable) {
          continue;
        }

        if (typeof element[key] === "function") {
          continue;
        }

        properties.add(key);
      }

      proto = Object.getPrototypeOf(proto);
    }

    return properties;
  }
  </script>

  <hr>

  <div>
    <p>
      The software is available under the
      <a
        href="./LICENSE"
      >MPL-2.0 license</a>.
    </p>
  </div>
</body>

</html>
